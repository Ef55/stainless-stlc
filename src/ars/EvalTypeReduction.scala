/**
  *  References: 
  *    - [TAPL] Types and Programming Languages, Benjamin C. Pierce, 2002, The MIT Press
  *    - [TRAT] Term Rewriting and All That, Franz Baader and Tobias Nipkow, 1998, Cambridge University Press
  * 
  *  This file defines usual reduction, applied at the type level.
  * 
  * 
  */

import stainless.lang._
import stainless.collection._
import stainless.annotation._
import LambdaOmega._
import TypeTransformations._
import ARS._
import ARSProperties._

object EvalTypeReduction{

  /**
    * Derivation tree for an usual type reduction step of the form type1 => type2.
    * The evaluation rules are alsmost the same as the one for terms in lambda calculus (TAPL Figure 5.3).
    * In addition, we add congruence rules for arrow types.
    * 
    * The tree represents a proof of the reduction.
    */
  sealed trait EvalReductionDerivation{

    @pure
    def type1: Type = 
      this match
        case ArrowTypeDerivationL(t1, _, _) => t1
        case ArrowTypeDerivationR(t1, _, _) => t1
        case AbsTypeDerivation(t1, _, _) => t1
        case AppTypeDerivationL(t1, _, _) => t1
        case AppTypeDerivationR(t1, _, _) => t1
        case AppAbsTypeDerivation(abs, arg) => AppType(abs, arg)
        case UniversalTypeDerivation(t1, _, _) => t1

    @pure
    def type2: Type = 
      this match
        case ArrowTypeDerivationL(_, t2, _) => t2
        case ArrowTypeDerivationR(_, t2, _) => t2
        case AbsTypeDerivation(_, t2, _) => t2
        case AppTypeDerivationL(_, t2, _) => t2
        case AppTypeDerivationR(_, t2, _) => t2
        case AppAbsTypeDerivation(abs, arg) => absSubstitution(abs.body, arg)
        case UniversalTypeDerivation(_, t2, _) => t2


    /**
      * Measure for evaluation reduction derivation trees
      * ! This is not a formal definition, its only purpose is to ensure measure decreaseness
      */
    @pure
    def size: BigInt = {
      decreases(this)
      this match
        case ArrowTypeDerivationL(_, _, rd) => rd.size + 1 
        case ArrowTypeDerivationR(_, _, rd) => rd.size + 1
        case AbsTypeDerivation(_, _, rd) => rd.size + 1
        case AppTypeDerivationL(_, _, rd) => rd.size + 1
        case AppTypeDerivationR(_, _, rd) => rd.size + 1
        case AppAbsTypeDerivation(_, _) => BigInt(1)
        case UniversalTypeDerivation(_, _, rd) => rd.size + 1
    }.ensuring(_ > BigInt(0))

    /**
      * Returns whether the derivation tree is sound.
      * Therefore, isSound is a verifier for the proof system generated by the reduction rules.
      *
      * For each derivation rule checks whether:
      * - each subtree is also sound
      * - the conclusions of the subtrees are the premises of the rule.
      */
    @pure
    def isSound: Boolean = 
      decreases(this)
      this match 
        case ArrowTypeDerivationL(ArrowType(t11, t12), ArrowType(t21, t22), rd) => 
          rd.isSound && rd.type1 == t11 && rd.type2 == t21 && t12 == t22
        case ArrowTypeDerivationR(ArrowType(t11, t12), ArrowType(t21, t22), rd) =>
          rd.isSound && rd.type1 == t12 && rd.type2 == t22 && t11 == t21
        case AbsTypeDerivation(AbsType(k1, b1), AbsType(k2, b2), rd) => 
          rd.isSound && rd.type1 == b1 && rd.type2 == b2 && k1 == k2
        case AppTypeDerivationL(AppType(t11, t12), AppType(t21, t22), rd) =>
          rd.isSound && rd.type1 == t11 && rd.type2 == t21 && t12 == t22
        case AppTypeDerivationR(AppType(t11, t12), AppType(t21, t22), rd) =>
          rd.isSound && rd.type1 == t12 && rd.type2 == t22 && t11 == t21
        case UniversalTypeDerivation(UniversalType(k1, b1), UniversalType(k2, b2), rd) => 
          rd.isSound && rd.type1 == b1 && rd.type2 == b2 && k1 == k2
        case AppAbsTypeDerivation(_, _) => true

    @pure @opaque @inlineOnce
    def toARSStep: EvalReductionStep = {
      (this, type1, type2, isSound)
    }.ensuring(res => res.isWellFormed && res.unfold == this)
  }

  /**
    * Evaluation reduction rules inspired from TAPL Figure 5-3
    */
  case class ArrowTypeDerivationL(t1: ArrowType, t2: ArrowType, rd: EvalReductionDerivation) extends EvalReductionDerivation
  case class ArrowTypeDerivationR(t1: ArrowType, t2: ArrowType, rd: EvalReductionDerivation) extends EvalReductionDerivation
  case class AbsTypeDerivation(t1: AbsType, t2: AbsType, rd: EvalReductionDerivation) extends EvalReductionDerivation
  case class AppTypeDerivationL(t1: AppType, t2: AppType, rd: EvalReductionDerivation) extends EvalReductionDerivation
  case class AppTypeDerivationR(t1: AppType, t2: AppType, rd: EvalReductionDerivation) extends EvalReductionDerivation
  case class AppAbsTypeDerivation(abs: AbsType, arg: Type) extends EvalReductionDerivation
  case class UniversalTypeDerivation(t1: UniversalType, t2: UniversalType, rd: EvalReductionDerivation) extends EvalReductionDerivation
  
  /**
   * Outputs the set of all the types to to which t reduces along with the proof of the reduction
   * 
   * ! Lists are used here instead of sets since their are easier to deal with in Stainless
   */
  @pure
  def reduce(t: Type): List[EvalReductionDerivation] = {
    decreases(t)
    t match
      case BasicType(_) => Nil()
      case VariableType(_) => Nil()
      case abs@AbsType(k, b) => reduce(b).map(b2 => AbsTypeDerivation(abs, AbsType(k, b2.type2), b2))
      case arr@ArrowType(t1, t2) => 
        val l1: List[EvalReductionDerivation] = reduce(t1).map(t1d => ArrowTypeDerivationL(arr, ArrowType(t1d.type2, t2), t1d))
        val l2: List[EvalReductionDerivation] = reduce(t2).map(t2d => ArrowTypeDerivationR(arr, ArrowType(t1, t2d.type2), t2d))
        l1 ++ l2
      case app@AppType(t1, t2) =>
        val l1: List[EvalReductionDerivation] = reduce(t1).map(t1d => AppTypeDerivationL(app, AppType(t1d.type2, t2), t1d))
        val l2: List[EvalReductionDerivation] = reduce(t2).map(t2d => AppTypeDerivationR(app, AppType(t1, t2d.type2), t2d))
        val l3: List[EvalReductionDerivation] = t1 match
          case abs@AbsType(k, b) =>
            Cons(AppAbsTypeDerivation(abs, t2), Nil())
          case _ => Nil()
        (l1 ++ l2) ++ l3
      case univ@UniversalType(k, b) => reduce(b).map(b2 => UniversalTypeDerivation(univ, UniversalType(k, b2.type2), b2))
  }

  /**
    * Decider procedure for reduction
    * If t1 -> t2 then the algorithm output a proof that witnesses the reduction
    */
  @pure
  def reducesTo(t1: Type, t2: Type): Option[EvalReductionDerivation] = {
    reduce(t1).filter((r: EvalReductionDerivation) => r.type2 == t2) match
      case Nil() => None()
      case Cons(h, t) => Some(h)
  }

  /**
    * List of technical lemmas needed to prove soundness of reduce
    */
  @pure @opaque @inlineOnce
  def reduceSoundnessLemmaAbs(@induct l: List[EvalReductionDerivation], k: Kind, b: Type): Unit = {
    require(l.forall(_.isSound))
    require(l.forall(_.type1 == b))
  }.ensuring(l.forall(b2 => AbsTypeDerivation(AbsType(k, b), AbsType(k, b2.type2), b2).isSound) &&
             l.forall(b2 => AbsTypeDerivation(AbsType(k, b), AbsType(k, b2.type2), b2).type1 == AbsType(k, b)))

  @pure @opaque @inlineOnce
  def reduceSoundnessLemmaArrL(@induct l: List[EvalReductionDerivation], t1: Type, t2: Type): Unit = {
    require(l.forall(_.isSound))
    require(l.forall(_.type1 == t1))
  }.ensuring(l.forall(t1d => ArrowTypeDerivationL(ArrowType(t1, t2), ArrowType(t1d.type2, t2), t1d).isSound) &&
             l.forall(t1d => ArrowTypeDerivationL(ArrowType(t1, t2), ArrowType(t1d.type2, t2), t1d).type1 == ArrowType(t1, t2)))

  @pure @opaque @inlineOnce
  def reduceSoundnessLemmaArrR(@induct l: List[EvalReductionDerivation], t1: Type, t2: Type): Unit = {
    require(l.forall(_.isSound))
    require(l.forall(_.type1 == t2))
  }.ensuring(l.forall(t2d => ArrowTypeDerivationR(ArrowType(t1, t2), ArrowType(t1, t2d.type2), t2d).isSound) &&
             l.forall(t2d => ArrowTypeDerivationR(ArrowType(t1, t2), ArrowType(t1, t2d.type2), t2d).type1 == ArrowType(t1, t2)))

  @pure @opaque @inlineOnce
  def reduceSoundnessLemmaAppL(@induct l: List[EvalReductionDerivation], t1: Type, t2: Type): Unit = {
    require(l.forall(_.isSound))
    require(l.forall(_.type1 == t1))
  }.ensuring(l.forall(t1d => AppTypeDerivationL(AppType(t1, t2), AppType(t1d.type2, t2), t1d).isSound) &&
             l.forall(t1d => AppTypeDerivationL(AppType(t1, t2), AppType(t1d.type2, t2), t1d).type1 == AppType(t1, t2)))

  @pure @opaque @inlineOnce
  def reduceSoundnessLemmaAppR(@induct l: List[EvalReductionDerivation], t1: Type, t2: Type): Unit = {
    require(l.forall(_.isSound))
    require(l.forall(_.type1 == t2))
  }.ensuring(l.forall(t2d => AppTypeDerivationR(AppType(t1, t2), AppType(t1, t2d.type2), t2d).isSound) &&
             l.forall(t2d => AppTypeDerivationR(AppType(t1, t2), AppType(t1, t2d.type2), t2d).type1 == AppType(t1, t2)))

  @pure @opaque @inlineOnce
  def reduceSoundnessLemmaUniversal(@induct l: List[EvalReductionDerivation], k: Kind, b: Type): Unit = {
    require(l.forall(_.isSound))
    require(l.forall(_.type1 == b))
  }.ensuring(l.forall(b2 => UniversalTypeDerivation(UniversalType(k, b), UniversalType(k, b2.type2), b2).isSound) &&
             l.forall(b2 => UniversalTypeDerivation(UniversalType(k, b), UniversalType(k, b2.type2), b2).type1 == UniversalType(k, b)))


  /**
    * Soudness of reduce
    * That is all the proofs in the set outputed by reduce are sound and they all witness T -> T' for some T'
    */
  @pure @opaque @inlineOnce
  def reduceSoundness(t: Type): Unit = {
    decreases(t)
    t match
      case BasicType(_) => ()
      case VariableType(_) => ()
      case abs@AbsType(k, b) => 
        reduceSoundness(b)
        reduceSoundnessLemmaAbs(reduce(b), k, b)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(b), (b2: EvalReductionDerivation) => AbsTypeDerivation(abs, AbsType(k, b2.type2), b2), (r: EvalReductionDerivation) => r.isSound)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(b), (b2: EvalReductionDerivation) => AbsTypeDerivation(abs, AbsType(k, b2.type2), b2), (r: EvalReductionDerivation) => r.type1 == t)
        assert(reduce(b).map((b2: EvalReductionDerivation) => AbsTypeDerivation(abs, AbsType(k, b2.type2), b2)).forall((r: EvalReductionDerivation) => r.isSound))

      case univ@UniversalType(k, b) => 
        reduceSoundness(b)
        reduceSoundnessLemmaUniversal(reduce(b), k, b)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(b), (b2: EvalReductionDerivation) => UniversalTypeDerivation(univ, UniversalType(k, b2.type2), b2), (r: EvalReductionDerivation) => r.isSound)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(b), (b2: EvalReductionDerivation) => UniversalTypeDerivation(univ, UniversalType(k, b2.type2), b2), (r: EvalReductionDerivation) => r.type1 == t)
        assert(reduce(b).map((b2: EvalReductionDerivation) => UniversalTypeDerivation(univ, UniversalType(k, b2.type2), b2)).forall((r: EvalReductionDerivation) => r.isSound))

      case arr@ArrowType(t1, t2) => 
        reduceSoundness(t1)
        reduceSoundness(t2)
        reduceSoundnessLemmaArrL(reduce(t1), t1, t2)
        reduceSoundnessLemmaArrR(reduce(t2), t1, t2)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(t1), (t1d: EvalReductionDerivation) => ArrowTypeDerivationL(arr, ArrowType(t1d.type2, t2), t1d), (r: EvalReductionDerivation) => r.isSound)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(t1), (t1d: EvalReductionDerivation) => ArrowTypeDerivationL(arr, ArrowType(t1d.type2, t2), t1d), (r: EvalReductionDerivation) => r.type1 == t)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(t2), (t2d: EvalReductionDerivation) => ArrowTypeDerivationR(arr, ArrowType(t1, t2d.type2), t2d), (r: EvalReductionDerivation) => r.isSound)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(t2), (t2d: EvalReductionDerivation) => ArrowTypeDerivationR(arr, ArrowType(t1, t2d.type2), t2d), (r: EvalReductionDerivation) => r.type1 == t)
        val l1: List[EvalReductionDerivation] = reduce(t1).map((t1d: EvalReductionDerivation) => ArrowTypeDerivationL(arr, ArrowType(t1d.type2, t2), t1d))
        val l2: List[EvalReductionDerivation] = reduce(t2).map((t2d: EvalReductionDerivation) => ArrowTypeDerivationR(arr, ArrowType(t1, t2d.type2), t2d))
        ListProperties.concatForall[EvalReductionDerivation](l1, l2, (r: EvalReductionDerivation) => r.isSound)
        ListProperties.concatForall[EvalReductionDerivation](l1, l2, (r: EvalReductionDerivation) => r.type1 == t)

      case app@AppType(t1, t2) =>
        reduceSoundness(t1)
        reduceSoundness(t2)
        reduceSoundnessLemmaAppL(reduce(t1), t1, t2)
        reduceSoundnessLemmaAppR(reduce(t2), t1, t2)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(t1), (t1d: EvalReductionDerivation) => AppTypeDerivationL(app, AppType(t1d.type2, t2), t1d), (r: EvalReductionDerivation) => r.isSound)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(t1), (t1d: EvalReductionDerivation) => AppTypeDerivationL(app, AppType(t1d.type2, t2), t1d), (r: EvalReductionDerivation) => r.type1 == t)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(t2), (t2d: EvalReductionDerivation) => AppTypeDerivationR(app, AppType(t1, t2d.type2), t2d), (r: EvalReductionDerivation) => r.isSound)
        ListSpecs.mapPred[EvalReductionDerivation, EvalReductionDerivation](reduce(t2), (t2d: EvalReductionDerivation) => AppTypeDerivationR(app, AppType(t1, t2d.type2), t2d), (r: EvalReductionDerivation) => r.type1 == t)
        val l1: List[EvalReductionDerivation] = reduce(t1).map((t1d: EvalReductionDerivation) => AppTypeDerivationL(app, AppType(t1d.type2, t2), t1d))
        val l2: List[EvalReductionDerivation] = reduce(t2).map((t2d: EvalReductionDerivation) => AppTypeDerivationR(app, AppType(t1, t2d.type2), t2d))
        ListProperties.concatForall[EvalReductionDerivation](l1, l2, (r: EvalReductionDerivation) => r.isSound)
        ListProperties.concatForall[EvalReductionDerivation](l1, l2, (r: EvalReductionDerivation) => r.type1 == t)
        val l3: List[EvalReductionDerivation] = t1 match
          case abs@AbsType(k, b) =>
            Cons(AppAbsTypeDerivation(abs, t2), Nil())
          case _ => Nil()
        assert((l1 ++ l2).forall((r: EvalReductionDerivation) => r.isSound))
        assert((l1 ++ l2).forall((r: EvalReductionDerivation) => r.type1 == t))
        ListProperties.concatForall[EvalReductionDerivation](l1 ++ l2, l3, (r: EvalReductionDerivation) => r.isSound)
        ListProperties.concatForall[EvalReductionDerivation](l1 ++ l2, l3, (r: EvalReductionDerivation) => r.type1 == t)
        t1 match
          case abs@AbsType(k, b) =>
            assert((Cons(AppAbsTypeDerivation(abs, t2), Nil())).forall((r: EvalReductionDerivation) => r.isSound))
            assert((Cons(AppAbsTypeDerivation(abs, t2), Nil())).forall((r: EvalReductionDerivation) => r.type1 == t))
          case _ => ()
        
  }.ensuring(reduce(t).forall((r: EvalReductionDerivation) => r.isSound) && reduce(t).forall((r: EvalReductionDerivation) => r.type1 == t))

  /**
   * Completeness of reduce
   * That is if T1 -> T2 then T2 ∈ reduce(T1)
   */
  @pure @opaque @inlineOnce
  def reduceCompleteness(r: EvalReductionDerivation): Unit = {
    decreases(r)
    require(r.isSound)
    
    r match
      case ArrowTypeDerivationL(ArrowType(t11, t12), ArrowType(t21, t22), rd) => 
        reduceCompleteness(rd)
        ListProperties.mapContains(reduce(t11), (t1d: EvalReductionDerivation) => ArrowTypeDerivationL(ArrowType(t11, t12), ArrowType(t1d.type2, t12), t1d), rd)
        val l1: List[EvalReductionDerivation] = reduce(t11).map(t1d => ArrowTypeDerivationL(ArrowType(t11, t12), ArrowType(t1d.type2, t12), t1d))
        val l2: List[EvalReductionDerivation] = reduce(t12).map(t2d => ArrowTypeDerivationR(ArrowType(t11, t12), ArrowType(t11, t2d.type2), t2d))
        ListProperties.concatContains(l1, l2, r)

      case ArrowTypeDerivationR(ArrowType(t11, t12), ArrowType(t21, t22), rd) =>
        reduceCompleteness(rd)
        ListProperties.mapContains(reduce(t12), (t2d: EvalReductionDerivation) => ArrowTypeDerivationR(ArrowType(t11, t12), ArrowType(t11, t2d.type2), t2d), rd)
        val l1: List[EvalReductionDerivation] = reduce(t11).map(t1d => ArrowTypeDerivationL(ArrowType(t11, t12), ArrowType(t1d.type2, t12), t1d))
        val l2: List[EvalReductionDerivation] = reduce(t12).map(t2d => ArrowTypeDerivationR(ArrowType(t11, t12), ArrowType(t11, t2d.type2), t2d))
        ListProperties.concatContains(l1, l2, r)

      case AbsTypeDerivation(AbsType(k1, b1), AbsType(k2, b2), rd) => 
        reduceCompleteness(rd)
        ListProperties.mapContains(reduce(b1), (bd: EvalReductionDerivation) => AbsTypeDerivation(AbsType(k1, b1), AbsType(k2, bd.type2), bd), rd)
        val l: List[EvalReductionDerivation] = reduce(b1).map(bd => AbsTypeDerivation(AbsType(k1, b1), AbsType(k2, bd.type2), bd))

      case UniversalTypeDerivation(UniversalType(k1, b1), UniversalType(k2, b2), rd) => 
        reduceCompleteness(rd)
        ListProperties.mapContains(reduce(b1), (bd: EvalReductionDerivation) => UniversalTypeDerivation(UniversalType(k1, b1), UniversalType(k2, bd.type2), bd), rd)
        val l: List[EvalReductionDerivation] = reduce(b1).map(bd => UniversalTypeDerivation(UniversalType(k1, b1), UniversalType(k2, bd.type2), bd))

      case AppTypeDerivationL(AppType(t11, t12), AppType(t21, t22), rd) =>
        reduceCompleteness(rd)
        ListProperties.mapContains(reduce(t11), (t1d: EvalReductionDerivation) => AppTypeDerivationL(AppType(t11, t12), AppType(t1d.type2, t12), t1d), rd)
        val l1: List[EvalReductionDerivation] = reduce(t11).map(t1d => AppTypeDerivationL(AppType(t11, t12), AppType(t1d.type2, t12), t1d))
        val l2: List[EvalReductionDerivation] = reduce(t12).map(t2d => AppTypeDerivationR(AppType(t11, t12), AppType(t11, t2d.type2), t2d))
        val l3: List[EvalReductionDerivation] = 
          t11 match
            case abs@AbsType(k, b) =>
              Cons(AppAbsTypeDerivation(abs, t12), Nil())
            case _ => Nil()
        ListProperties.concatContains(l1, l2, r)
        ListProperties.concatContains(l1 ++ l2, l3, r)

      case AppTypeDerivationR(AppType(t11, t12), AppType(t21, t22), rd) =>
        reduceCompleteness(rd)
        ListProperties.mapContains(reduce(t12), (t2d: EvalReductionDerivation) => AppTypeDerivationR(AppType(t11, t12), AppType(t11, t2d.type2), t2d), rd)
        val l1: List[EvalReductionDerivation] = reduce(t11).map(t1d => AppTypeDerivationL(AppType(t11, t12), AppType(t1d.type2, t12), t1d))
        val l2: List[EvalReductionDerivation] = reduce(t12).map(t2d => AppTypeDerivationR(AppType(t11, t12), AppType(t11, t2d.type2), t2d))
        val l3: List[EvalReductionDerivation] = 
          t11 match
            case abs@AbsType(k, b) =>
              Cons(AppAbsTypeDerivation(abs, t12), Nil())
            case _ => Nil()
        ListProperties.concatContains(l1, l2, r)
        ListProperties.concatContains(l1 ++ l2, l3, r)

      case AppAbsTypeDerivation(t11, t12) => 
        val l1: List[EvalReductionDerivation] = reduce(t11).map(t1d => AppTypeDerivationL(AppType(t11, t12), AppType(t1d.type2, t12), t1d))
        val l2: List[EvalReductionDerivation] = reduce(t12).map(t2d => AppTypeDerivationR(AppType(t11, t12), AppType(t11, t2d.type2), t2d))
        val l3: List[EvalReductionDerivation] = 
          t11 match
            case abs@AbsType(k, b) =>
              Cons(AppAbsTypeDerivation(abs, t12), Nil())
            case _ => Nil()
        assert(l3.contains(r))
        ListProperties.concatContains(l1 ++ l2, l3, r)
  }.ensuring(reduce(r.type1).contains(r))

  /**
   * Normal form - TRAT Section 2.1.1
   */
  @pure
  def isEvalNormalForm(t: Type): Boolean = {
    reduce(t).isEmpty
  }

  @pure @inlineOnce @pure
  def isEvalNormalFormArrowMap(t1: Type, t2: Type): Unit = {
    require(isEvalNormalForm(t1))
    require(isEvalNormalForm(t2))
    val l1: List[EvalReductionDerivation] = reduce(t1).map(t1d => ArrowTypeDerivationL(ArrowType(t1, t2), ArrowType(t1d.type2, t2), t1d))
    assert(l1.isEmpty)
    val l2: List[EvalReductionDerivation] = reduce(t2).map(t2d => ArrowTypeDerivationR(ArrowType(t1, t2), ArrowType(t1, t2d.type2), t2d))
    assert(l2.isEmpty)
    assert((l1 ++ l2).isEmpty)
    assert(reduce(ArrowType(t1, t2)) == l1 ++ l2)
  }.ensuring(isEvalNormalForm(ArrowType(t1, t2)))

  @pure @inlineOnce @pure
  def isEvalNormalFormInnerMap(t: Type): Unit = {
    require(isEvalNormalForm(t))
    t match
      case abs@AbsType(k, b) => 
        val l = reduce(b).map(b2 => AbsTypeDerivation(abs, AbsType(k, b2.type2), b2))
        assert(l.isEmpty)
      case univ@UniversalType(k, b) => 
        val l = reduce(b).map(b2 => UniversalTypeDerivation(univ, UniversalType(k, b2.type2), b2))
        assert(l.isEmpty)
      case arr@ArrowType(t1, t2) => 
        val l1: List[EvalReductionDerivation] = reduce(t1).map(t1d => ArrowTypeDerivationL(arr, ArrowType(t1d.type2, t2), t1d)) 
        val l2: List[EvalReductionDerivation] = reduce(t2).map(t2d => ArrowTypeDerivationR(arr, ArrowType(t1, t2d.type2), t2d))    
        assert((l1 ++ l2).isEmpty)
        assert(l1.isEmpty)
        assert(l2.isEmpty)     
      case app@AppType(t1, t2) =>
        val l1: List[EvalReductionDerivation] = reduce(t1).map(t1d => AppTypeDerivationL(app, AppType(t1d.type2, t2), t1d))    
        val l2: List[EvalReductionDerivation] = reduce(t2).map(t2d => AppTypeDerivationR(app, AppType(t1, t2d.type2), t2d))
        val l3: List[EvalReductionDerivation] = t1 match
          case abs@AbsType(k, b) =>
            Cons(AppAbsTypeDerivation(abs, t2), Nil())
          case _ => Nil()
        assert(((l1 ++ l2) ++ l3).isEmpty)
        assert((l1 ++ l2).isEmpty)
        assert(l1.isEmpty)
        assert(l2.isEmpty)
      case _ => ()
    
  }.ensuring(t match
    case ArrowType(t1, t2) => isEvalNormalForm(t1) && isEvalNormalForm(t2)
    case AppType(t1, t2) => isEvalNormalForm(t1) && isEvalNormalForm(t2)
    case AbsType(_, b) => isEvalNormalForm(b)
    case _ => true
  )

  /**
    * Full Beta Reduction - TAPL 5.1 Operational Semantics
    * Reduction strategy where reduction is applied whenever it is possible
    * The procedure outputs a proof witnessing the reduction
    */
  @pure
  def fullBetaReduce(t: Type): Option[EvalReductionDerivation] = {
    decreases(t)
    t match
      case at@ArrowType(t11, t12) =>
        fullBetaReduce(t11) match 
          case Some(prd1) => Some(ArrowTypeDerivationL(at, ArrowType(prd1.type2, t12), prd1))
          case _ => fullBetaReduce(t12) match
            case Some(prd2) => Some(ArrowTypeDerivationR(at, ArrowType(t11, prd2.type2), prd2))
            case _ => None()

      case (at@AppType(t11, t12)) =>
        fullBetaReduce(t11) match 
          case Some(prd1) => Some(AppTypeDerivationL(at, AppType(prd1.type2, t12), prd1))
          case _ => fullBetaReduce(t12) match 
            case Some(prd2) => Some(AppTypeDerivationR(at, AppType(t11, prd2.type2), prd2))
            case _ => t11 match 
              case abs@AbsType(argK, body) => Some(AppAbsTypeDerivation(abs, t12))
              case _ => None()
      
      case (abs@AbsType(k, b)) =>
        fullBetaReduce(b) match
          case Some(prd) => Some(AbsTypeDerivation(abs, AbsType(k, prd.type2), prd))
          case _ => None()

      case (univ@UniversalType(k, b)) =>
        fullBetaReduce(b) match
          case Some(prd) => Some(UniversalTypeDerivation(univ, UniversalType(k, prd.type2), prd))
          case _ => None()

      case _ => None()
  }

  /**
   * Full beta reduction soudness
   * That is the proof witnessing T -> T' is sound
   */
  @pure @opaque @inlineOnce
  def fullBetaReduceSoundness(t: Type): Unit = {
    decreases(t)
    require(fullBetaReduce(t).isDefined)
    t match
      case at@ArrowType(t11, t12) =>
        fullBetaReduce(t11) match 
          case Some(prd1) => fullBetaReduceSoundness(t11)
          case _ => fullBetaReduce(t12) match
            case Some(prd2) => fullBetaReduceSoundness(t12)
            case None() => ()
          
      case at@AppType(t11, t12) =>
        fullBetaReduce(t11) match 
          case Some(prd1) => fullBetaReduceSoundness(t11)
          case _ => fullBetaReduce(t12) match 
            case Some(prd2) => fullBetaReduceSoundness(t12)
            case _ => t11 match 
              case AbsType(argK, body) => ()
              case _ => ()

      case (AbsType(k, b)) =>
        fullBetaReduce(b) match
          case Some(prd) => fullBetaReduceSoundness(b)
          case _ => ()

      case (UniversalType(k, b)) =>
        fullBetaReduce(b) match
          case Some(prd) => fullBetaReduceSoundness(b)
          case _ => ()

      case _ => ()

  }.ensuring(fullBetaReduce(t).get.isSound && fullBetaReduce(t).get.type1 == t)

  /**
   * Full beta reduction completeness
   * That is a type is reducible then it is also reducible under full beta reduction
   */
  @pure @opaque @inlineOnce
  def fullBetaReduceCompleteness(@induct r: EvalReductionDerivation): Unit = {
    require(r.isSound)
  }.ensuring(_ => fullBetaReduce(r.type1).isDefined)

  /**
    * Outputs if T1 -> T2 according to full beta reduction
    * If it is the case, outputs a proof of the reduction
    */
  @pure
  def fullBetaReducesTo(t1: Type, t2: Type): Option[EvalReductionDerivation] = {
    fullBetaReduce(t1) match
      case Some(prd) => if prd.type2 == t2 then Some(prd) else None()
      case None() => None()
  }

  /**
   * Soudness of fullBetaReducesTo
   * That is if the procedure outputs a proof of T1 -> T2, then it is sound
   */
  @pure @opaque @inlineOnce
  def fullBetaReducesToSoundness(t1: Type, t2: Type): Unit = {
    require(fullBetaReducesTo(t1, t2).isDefined)
    fullBetaReduceSoundness(t1)
  }.ensuring(fullBetaReducesTo(t1, t2).get.isSound && fullBetaReducesTo(t1, t2).get.type1 == t1 && fullBetaReducesTo(t1, t2).get.type2 == t2)

  /**
   * Completeness of fullBetaReducesTo
   * That is if fullBetaReduce(T1) = T2 then fullBetaReducesTo(T1, T2) is defined
   */
  @pure @opaque @inlineOnce
  def fullBetaReducesToCompleteness(r: EvalReductionDerivation): Unit = {
    require(r.isSound)
    fullBetaReduceCompleteness(r)
  }.ensuring(_ => 
    fullBetaReduce(r.type1).isDefined &&
    fullBetaReducesTo(r.type1, fullBetaReduce(r.type1).get.type2) == fullBetaReduce(r.type1))

  /**
   * 
   */
  @pure @opaque @inlineOnce
  def reduceIffFullBetaReduce(t1: Type): Unit = {
    reduceSoundness(t1)
    (reduce(t1), fullBetaReduce(t1)) match
      case (Nil(), None()) => ()
      case (Cons(r, t), _) => 
        fullBetaReduceCompleteness(r)
      case (_, Some(r)) =>
        fullBetaReduceSoundness(t1)
        reduceCompleteness(r)
  }.ensuring(isEvalNormalForm(t1) == !fullBetaReduce(t1).isDefined)

  type EvalReductionStep = ARSStep[Type, EvalReductionDerivation]
  type MultiStepEvalReduction = ARSKFoldComposition[Type, EvalReductionDerivation]
  type EvalEquivalence = ARSEquivalence[Type, EvalReductionDerivation]

  extension (s: EvalReductionStep){
    @pure
    def isWellFormed: Boolean = s.unfold.type1 == s.t1 && s.unfold.type2 == s.t2 && s.unfold.isSound == s.isSound
    @pure
    def isValid: Boolean = s.isSound && s.isWellFormed
  }

  extension (ms: MultiStepEvalReduction){
    @pure
    def isWellFormed: Boolean =
      decreases(ms)
      ms match
        case ARSIdentity(t) => true
        case ARSComposition(h, t) => h.isWellFormed && t.isWellFormed
    
    @pure
    def isValid: Boolean = {   
      decreases(ms)
      ms match
          case ARSIdentity(t) => true
          case ARSComposition(h, t) => h.isValid && t.isValid && h.t2 == t.t1
    }.ensuring(_ == (ms.isSound && ms.isWellFormed))
  }

  extension (ms: EvalEquivalence){
    @pure
    def isWellFormed: Boolean =
      decreases(ms)
      ms match
        case ARSReflexivity(t) => true
        case ARSBaseRelation(r) => r.isWellFormed
        case ARSTransitivity(r1, r2) => r1.isWellFormed && r2.isWellFormed
        case ARSSymmetry(r) => r.isWellFormed

    @pure
    def isValid: Boolean = {
      ms.isSound && ms.isWellFormed  
    }
  }

}

/**
  * All theorems and operation used in this file are well formed
  */
object EvalTypeReductionValidity{

  import EvalTypeReduction.*

  @pure @opaque @inlineOnce
  def concatWellFormed(@induct s1: MultiStepEvalReduction, s2: MultiStepEvalReduction): Unit = {
    require(s1.isWellFormed)
    require(s2.isWellFormed)
  }.ensuring(s1.concat(s2).isWellFormed)

  @pure @opaque @inlineOnce
  def toReflTransWellFormed(@induct ms: MultiStepEvalReduction): Unit = {
    require(ms.isWellFormed)
  }.ensuring(ms.toReflTrans.isWellFormed)

  @pure @opaque @inlineOnce
  def kFoldInverseToReflTransWellFormed(ms: MultiStepEvalReduction): Unit = {
    require(ms.isValid)
    toReflTransWellFormed(ms)
  }.ensuring(kFoldInverseToReflTrans(ms).isWellFormed)

  @pure @opaque @inlineOnce
  def reductionPreserveEquivalenceWellFormed(ms1: MultiStepEvalReduction, ms2: MultiStepEvalReduction, eq: EvalEquivalence) = {
    require(ms1.isValid)
    require(ms2.isValid)
    require(eq.isValid)
    require(ms1.t1 == eq.t1)
    require(ms2.t1 == eq.t2)
    kFoldInverseToReflTransWellFormed(ms1)
    toReflTransWellFormed(ms2)
  }.ensuring(reductionPreserveEquivalence(ms1, ms2, eq).isWellFormed)

  @pure @opaque @inlineOnce
  def reductionImpliesEquivalenceWellFormed(ms1: MultiStepEvalReduction, ms2: MultiStepEvalReduction, eq: EvalEquivalence): Unit = {
    require(ms1.isValid)
    require(ms2.isValid)
    require(eq.isValid)
    require(ms1.t2 == eq.t1)
    require(ms2.t2 == eq.t2)
    toReflTransWellFormed(ms1)
    kFoldInverseToReflTransWellFormed(ms2)
  }.ensuring(reductionImpliesEquivalence(ms1, ms2, eq).isWellFormed)

  @pure @opaque @inlineOnce
  def reduceSameFormEquivalentWellFormed(ms1: MultiStepEvalReduction, ms2: MultiStepEvalReduction): Unit = {
    require(ms1.isValid)
    require(ms2.isValid)
    require(ms1.t2 == ms2.t2)
    reductionImpliesEquivalenceWellFormed(ms1, ms2, ARSReflexivity(ms1.t2))
  }.ensuring(reduceSameFormEquivalent(ms1, ms2).isWellFormed)

}

object EvalTypeReductionProperties {

  import EvalTypeReduction._
  import EvalTypeReductionValidity._

  /**
   * Soudness of reduction mapping for ArrowTypeDerivationL
   * 
   * * Short version: If T1 -k-> T1' then (T1 -> T2) -k-> (T1' -> T2)
   * 
   * Long version:
   *
   * Preconditions:
   *   - prd, the step sequence witnessing T1 -k-> T1' isValid
   * 
   * Postcondition:
   *   There exists a step sequence witnessing (T -> T2) -k'-> (T' -> T2) such that:
   *     - T  = T1
   *     - T' = T1'
   *     - k  = k'
   * 
   * * The proof is constructive and outputs this step sequence
   */
  @pure @opaque @inlineOnce
  def arrowDerivationLMap(prd1: MultiStepEvalReduction, t2: Type): MultiStepEvalReduction = {
    decreases(prd1)
    require(prd1.isValid)
    prd1 match
      case ARSIdentity(t1) => ARSIdentity(ArrowType(t1, t2))
      case ARSComposition(h, t) => ARSComposition(ArrowTypeDerivationL(ArrowType(h.t1, t2), ArrowType(h.t2, t2), h.unfold).toARSStep, arrowDerivationLMap(t, t2))
    
  }.ensuring(res => res.isValid && res.t1 == ArrowType(prd1.t1, t2) && res.t2 == ArrowType(prd1.t2, t2) && res.size == prd1.size)
  
  /**
   * Soudness of reduction mapping for AppTypeDerivationR
   * 
   * * Short version: If T2 -k-> T2' then (T1 -> T2) -k-> (T1 -> T2')
   * 
   * Long version:
   *
   * Preconditions:
   *   - prd, the step sequence witnessing T2 -k-> T2' isValid
   * 
   * Postcondition:
   *   There exists a step sequence witnessing (T1 -> T) -k'-> (T1 -> T') such that:
   *     - T  = T2
   *     - T' = T2'
   *     - k  = k'
   * 
   * * The proof is constructive and outputs this step sequence
   */
  @pure @opaque @inlineOnce
  def arrowDerivationRMap(t1: Type, prd2: MultiStepEvalReduction): MultiStepEvalReduction = {
    decreases(prd2)
    require(prd2.isValid)
    prd2 match
      case ARSIdentity(t2) => ARSIdentity(ArrowType(t1, t2))
      case ARSComposition(h, t) => ARSComposition(ArrowTypeDerivationR(ArrowType(t1, h.t1), ArrowType(t1, h.t2), h.unfold).toARSStep, arrowDerivationRMap(t1, t))
    
  }.ensuring(res => res.isValid && res.t1 == ArrowType(t1, prd2.t1) && res.t2 == ArrowType(t1, prd2.t2) && res.size == prd2.size)

  /**
   * Soudness of reduction mapping for AppTypeDerivationL
   * 
   * * Short version: If T1 -k-> T1' then T1 T2 -k-> T1' T2
   * 
   * Long version:
   *
   * Preconditions:
   *   - prd, the step sequence witnessing T1 -k-> T1' isValid
   * 
   * Postcondition:
   *   There exists a step sequence witnessing T T2 -k'-> T' T2 such that:
   *     - T  = T1
   *     - T' = T1'
   *     - k  = k'
   * 
   * * The proof is constructive and outputs this step sequence
   */
  @pure @opaque @inlineOnce
  def appDerivationLMap(prd1: MultiStepEvalReduction, t2: Type): MultiStepEvalReduction = {
    decreases(prd1)
    require(prd1.isValid)
    prd1 match
      case ARSIdentity(t1) => ARSIdentity(AppType(t1, t2))
      case ARSComposition(h, t) => ARSComposition(AppTypeDerivationL(AppType(h.t1, t2), AppType(h.t2, t2), h.unfold).toARSStep, appDerivationLMap(t, t2))
    
  }.ensuring(res => res.isValid && res.t1 == AppType(prd1.t1, t2) && res.t2 == AppType(prd1.t2, t2) && res.size == prd1.size)

  /**
   * Soudness of reduction mapping for AppTypeDerivationR
   * 
   * * Short version: If T2 -k-> T2' then T1 T2 -k-> T1 T2'
   * 
   * Long version:
   *
   * Preconditions:
   *   - prd, the step sequence witnessing T2 -k-> T2' isValid
   * 
   * Postcondition:
   *   There exists a step sequence witnessing T1 T -k'-> T1 T' such that:
   *     - T  = T2
   *     - T' = T2'
   *     - k  = k'
   * 
   * * The proof is constructive and outputs this step sequence
   */
  @pure @opaque @inlineOnce
  def appDerivationRMap(t1: Type, prd2: MultiStepEvalReduction): MultiStepEvalReduction = {
    decreases(prd2)
    require(prd2.isValid)
    prd2 match
      case ARSIdentity(t2) => ARSIdentity(AppType(t1, t2))
      case ARSComposition(h, t) => ARSComposition(AppTypeDerivationR(AppType(t1, h.t1), AppType(t1, h.t2), h.unfold).toARSStep, appDerivationRMap(t1, t))
    
  }.ensuring(res => res.isValid && res.t1 == AppType(t1, prd2.t1) && res.t2 == AppType(t1, prd2.t2) && res.size == prd2.size)

  /**
   * Soudness of reduction mapping for AbsTypeDerivation
   * 
   * * Short version: If T1 -k-> T2 then λ.T1 -k-> λ.T2
   * 
   * Long version:
   *
   * Preconditions:
   *   - prd, the step sequence witnessing T1 -k-> T2 isValid
   * 
   * Postcondition:
   *   There exists a step sequence witnessing λ.T -k'-> λ.T' such that:
   *     - T  = T1
   *     - T' = T2
   *     - k  = k'
   * 
   * * The proof is constructive and outputs this step sequence
   */
  @pure @opaque @inlineOnce
  def absDerivationMap(k: Kind, prd: MultiStepEvalReduction): MultiStepEvalReduction = {
    decreases(prd)
    require(prd.isValid)
    prd match
      case ARSIdentity(b) => ARSIdentity(AbsType(k, b))
      case ARSComposition(h, t) => ARSComposition(AbsTypeDerivation(AbsType(k, h.t1), AbsType(k, h.t2), h.unfold).toARSStep, absDerivationMap(k, t))
    
  }.ensuring(res => res.isValid && res.t1 == AbsType(k, prd.t1) && res.t2 == AbsType(k, prd.t2) && res.size == prd.size)

  /**
   * Soudness of reduction mapping for UniversalTypeDerivation
   * 
   * * Short version: If T1 -k-> T2 then ∀.T1 -k-> ∀.T2
   * 
   * Long version:
   *
   * Preconditions:
   *   - prd, the step sequence witnessing T1 -k-> T2 isValid
   * 
   * Postcondition:
   *   There exists a step sequence witnessing ∀.T -k'-> ∀.T' such that:
   *     - T  = T1
   *     - T' = T2
   *     - k  = k'
   * 
   * * The proof is constructive and outputs this step sequence
   */
  @pure @opaque @inlineOnce
  def universalDerivationMap(k: Kind, prd: MultiStepEvalReduction): MultiStepEvalReduction = {
    decreases(prd)
    require(prd.isValid)
    prd match
      case ARSIdentity(b) => ARSIdentity(UniversalType(k, b))
      case ARSComposition(h, t) => ARSComposition(UniversalTypeDerivation(UniversalType(k, h.t1), UniversalType(k, h.t2), h.unfold).toARSStep, universalDerivationMap(k, t))
    
  }.ensuring(res => res.isValid && res.t1 == UniversalType(k, prd.t1) && res.t2 == UniversalType(k, prd.t2) && res.size == prd.size)
}

object EvalTypeReductionConfluence {

  import ARSEquivalences._
  import ParallelTypeReduction._
  import EvalTypeReduction._
  import EvalTypeReductionValidity.*

  /**
    * Confluence - TRAT Definition 2.1.3, TAPL Lemma 30.3.9
    * 
    * * Short version: If T1 -m-> T2 and T1 -n-> T3 then there exits a type T4 such that T2 -n'-> T4 and T3 -m'-> T4
    * 
    * Long version:
    * 
    * Preconditions:
    *   - prd1, the list of derivation trees witnessing T11 -m-> T2 is sound
    *   - prd2, the list of derivation trees witnessing T12 -n-> T3 is sound
    *   - T11 = T12 (= T1 in the above theorem statement)
    *
    * Postcondition:
    *   There exists two sound list of derivation trees respectevely witnessing T -n'-> T41 and T' -m'-> T42 such that:
    *     - T = T2
    *     - T'= T3
    *     - T41 = T42
    * * The proof is constructive and returns this pair of list
    */
  @pure @opaque @inlineOnce
  def evalConfluence(prd1: MultiStepEvalReduction, prd2: MultiStepEvalReduction): (MultiStepEvalReduction, MultiStepEvalReduction) = {
    decreases(prd1.size + prd2.size)
    require(prd1.isValid)
    require(prd2.isValid)
    require(prd1.t1 == prd2.t1)

    val res = ParallelTypeReductionProperties.confluence(evalToParallel(prd1), evalToParallel(prd2))
    (parallelToEval(res._1), parallelToEval(res._2))
    
  }.ensuring(res => 
    res._1.t2 == res._2.t2 &&
    res._1.t1 == prd1.t2 &&
    res._2.t1 == prd2.t2 &&
    res._1.isValid && res._2.isValid
  )

  /**
    * Church Rosser Property - TRAT Definition 2.1.3
    * 
    * * Short version: If T1 <->* T2 then there exits a type T3 such that T1 -m-> T3 and T2 -n-> T3
    * 
    * Long version:
    * 
    * Preconditions:
    *   - eq, the witness of T1 <->* T2 is valid
    *
    * Postcondition:
    *   There exists two sound list of derivation trees respectevely witnessing T -m-> T31 and T' -n-> T32 such that:
    *     - T = T1
    *     - T'= T2
    *     - T31 = T32
    * * The proof is constructive and returns this pair of list
    */
  @pure @opaque @inlineOnce
  def churchRosser(eq: EvalEquivalence): (MultiStepEvalReduction, MultiStepEvalReduction) = {
    require(eq.isValid)

    val res = ParallelTypeReductionProperties.churchRosser(evalToParallel(eq))
    (parallelToEval(res._1), parallelToEval(res._2))

  }.ensuring(res => 
    res._1.t2 == res._2.t2 &&
    res._1.t1 == eq.t1 &&
    res._2.t1 == eq.t2 &&
    res._1.isValid && res._2.isValid
  )

  /**
    * Unique normal form - TRAT Fact 2.1.7
    *
    * * Short version: If T1 =m=> T2, T1 =n=> T3 and T2 and T3 are normal forms then T2 = T3
    * 
    * Long version:
    * 
    * Preconditions:
    *   - ms1, the step sequence witnessing T11 =m=> T2 is valid
    *   - ms2, the step sequence witnessing T12 =n=> T3 is valid
    *   - T11 = T12 (= T1 above)
    *   - T11 and T12 are normal forms
    * 
    * Postcondition: T2 = T3
    */
  @pure @opaque @inlineOnce
  def uniqueNormalForm(ms1: MultiStepEvalReduction, ms2: MultiStepEvalReduction): Unit = {
    require(ms1.isValid)
    require(ms2.isValid)
    require(ms1.t1 == ms2.t1)
    require(isEvalNormalForm(ms1.t2))
    require(isEvalNormalForm(ms2.t2))

    evalConfluence(ms1, ms2) match
      case (ARSIdentity(t1), ARSIdentity(t2)) => ()
      case (ARSComposition(h1, t1), _) => 
        assert(h1.isValid) //needed
        reduceCompleteness(h1.unfold)
      case (_, ARSComposition(h2, t2)) => 
        assert(h2.isValid) //needed
        reduceCompleteness(h2.unfold)

  }.ensuring(ms1.t2 == ms2.t2)

  /**
    * Equivalent normal forms are equal - TRAT Corollary 2.1.6
    * 
    * * Short version: If T1 and T2 are normal forms and T1 ≡ T2 then T1 = T2
    * 
    * Preconditions:
    *  - eq, the witness of T1 ≡ T2 is valid
    *  - T1 and T2 are normal forms
    * 
    * Postcondition: T1 = T2
    * 
    */
  @pure @opaque @inlineOnce
  def equivalentNormalFormEqual(eq: EvalEquivalence): Unit = {
    require(isEvalNormalForm(eq.t1))
    require(isEvalNormalForm(eq.t2))
    require(eq.isValid)
    
    churchRosser(eq) match
      case (ARSIdentity(_), ARSIdentity(_)) => ()
      case (ARSComposition(h, t), _) => 
        assert(h.isValid)
        reduceCompleteness(h.unfold)
      case (_, ARSComposition(h, t)) => 
        assert(h.isValid)
        reduceCompleteness(h.unfold)

  }.ensuring(eq.t1 == eq.t2)

  @pure @opaque @inlineOnce
  def equivalenceToReductionNormalForm(eq: ParallelEquivalence): MultiStepEvalReduction = {
    require(eq.isValid)
    require(isEvalNormalForm(eq.t2))
    val eeq = parallelToEval(eq)
    val (erd1, erd2) = churchRosser(eeq)
    erd2 match
      case ARSIdentity(_) => erd1
      case ARSComposition(h, t) =>
        assert(h.isValid)
        reduceCompleteness(h.unfold)
        erd1
  }.ensuring(res =>
    res.isValid && 
    eq.t1 == res.t1 &&
    eq.t2 == res.t2  
  )
}
